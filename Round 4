from datamodel import Order
from collections import deque
import math


class Trader:
    def __init__(self):
        # Rolling window length for per-asset stats
        self.window = 80

        # Z-score thresholds
        self.z_entry = 2.0
        self.z_exit = 0.75

        # Position limit per product (round 4 = 60 in main.py)
        self.max_pos = 60

        # Per-asset state
        # stats[product] = {
        #   "prices": deque([...]),
        #   "sum": float,
        #   "sum_sq": float,
        # }
        self.stats = {}
        self.assets = None

    def _ensure_asset(self, product):
        if product not in self.stats:
            self.stats[product] = {
                "prices": deque(maxlen=self.window),
                "sum": 0.0,
                "sum_sq": 0.0,
            }

    def _update_price_stats(self, product, mid_price):
        s = self.stats[product]
        prices = s["prices"]

        # If deque is full, removing oldest will happen automatically
        if len(prices) == prices.maxlen:
            oldest = prices[0]
            s["sum"] -= oldest
            s["sum_sq"] -= oldest * oldest

        prices.append(mid_price)
        s["sum"] += mid_price
        s["sum_sq"] += mid_price * mid_price

        n = len(prices)
        if n == 0:
            return mid_price, 0.0

        mean = s["sum"] / n
        if n > 1:
            avg_sq = s["sum_sq"] / n
            var = max(0.0, avg_sq - mean * mean)
            std = math.sqrt(var)
        else:
            std = 0.0

        return mean, std

    def _compute_z(self, price, mean, std):
        if std <= 1e-9:
            return 0.0
        return (price - mean) / std

    def run(self, state):
        """
        Main entry point called by the simulator each tick.
        `state` is a TradingState object from datamodel.py.
        We must return a flat list of Order objects.
        """
        # Use simulator's positions dict if present
        sim_positions = getattr(state, "positions", {})  # dict[product] -> int

        # Discover assets on first tick
        orderbook = state.orderbook  # dict[product] -> {"BUY": {price: vol}, "SELL": {price: vol}}
        if self.assets is None:
            self.assets = list(orderbook.keys())

        all_orders = []

        for product in self.assets:
            book = orderbook.get(product, None)
            if book is None:
                continue

            buys = book.get("BUY", {})
            sells = book.get("SELL", {})

            if not buys or not sells:
                # Need both sides of the book
                continue

            best_bid = max(buys.keys())
            best_ask = min(sells.keys())
            if best_ask <= best_bid:
                # Locked / crossed, be cautious
                mid = 0.5 * (best_bid + best_ask)
            else:
                mid = 0.5 * (best_bid + best_ask)

            # Ensure per-asset stats exist and update them
            self._ensure_asset(product)
            mean, std = self._update_price_stats(product, mid)
            z = self._compute_z(mid, mean, std)

            pos = sim_positions.get(product, 0)

            spread = best_ask - best_bid

            asset_orders = []

            # ---------- Mean-reversion core ----------
            # If price is rich vs recent mean -> sell
            if z > self.z_entry and pos > -self.max_pos:
                # aggressive sell at best bid
                vol = min(3, self.max_pos + pos)  # pos is positive when long
                asset_orders.append(Order(product, best_bid, -vol))

            # If price is cheap vs recent mean -> buy
            elif z < -self.z_entry and pos < self.max_pos:
                # aggressive buy at best ask
                vol = min(3, self.max_pos - pos)
                asset_orders.append(Order(product, best_ask, vol))

            # ---------- Spread capture / market making ----------
            # Only if we are not at the edges of position
            if spread >= 2:
                # Passive quotes just inside the spread
                if pos < self.max_pos:
                    bid_price = best_bid + 1
                    vol = min(2, self.max_pos - pos)
                    asset_orders.append(Order(product, bid_price, vol))

                if pos > -self.max_pos:
                    ask_price = best_ask - 1
                    vol = min(2, self.max_pos + pos)
                    asset_orders.append(Order(product, ask_price, -vol))

            # ---------- Light de-risking near flat ----------
            # If z has collapsed back towards 0, gently mean-revert our inventory
            if abs(z) < self.z_exit and abs(pos) > 0:
                # Try to move position one step towards 0 using best prices
                step = min(2, abs(pos))
                if pos > 0:
                    # Long -> sell a little at bid
                    asset_orders.append(Order(product, best_bid, -step))
                else:
                    # Short -> buy a little at ask
                    asset_orders.append(Order(product, best_ask, step))

            all_orders.extend(asset_orders)

        return all_orders
