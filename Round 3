from datamodel import Order  # datamodel should provide Order class
from collections import deque
import math

class Trader:
    def __init__(self):
        self.positions = {}
        self.price_history = {}
        self.position_limit = 50
        self.risk_free_rate = 0.05
        self.time_to_expiry = 1.0  # 1 year to expiry
        # Strike price (known/estimated)
        self.strike_price = 105.0

    def run(self, state):
        orders = []

        # Identify products
        underlying = None
        call_name = None
        put_name = None

        for product in state.products:
            # Initialize tracking
            if product not in self.positions:
                self.positions[product] = 0
            if product not in self.price_history:
                self.price_history[product] = deque(maxlen=100)

            # Categorize products
            pname = product.lower()
            if pname == "underlying":
                underlying = product
            elif "call" in pname:
                call_name = product
            elif "put" in pname:
                put_name = product

        # Require underlying, call, and put
        if not underlying or not call_name or not put_name:
            return orders

        # Get underlying orderbook
        underlying_book = state.orderbook.get(underlying)
        if not underlying_book or not underlying_book["BUY"] or not underlying_book["SELL"]:
            return orders

        # Compute underlying mid price
        underlying_bid = max(underlying_book["BUY"].keys())
        underlying_ask = min(underlying_book["SELL"].keys())
        underlying_mid = (underlying_bid + underlying_ask) / 2.0

        # Update history for realized volatility
        self.price_history[underlying].append(underlying_mid)
        if len(self.price_history[underlying]) >= 2:
            returns = []
            prices = list(self.price_history[underlying])
            for i in range(1, len(prices)):
                if prices[i-1] != 0:
                    returns.append((prices[i] - prices[i-1]) / prices[i-1])
            if returns:
                daily_vol = math.sqrt(sum(r**2 for r in returns) / len(returns))
                realized_vol = daily_vol * math.sqrt(252)  # annualize
            else:
                realized_vol = 0.2
        else:
            realized_vol = 0.2

        # Orderbooks for call and put
        call_book = state.orderbook.get(call_name)
        put_book = state.orderbook.get(put_name)

        # Strategy 1: Put-Call Parity Arbitrage (C - P â‰ˆ S - K*e^{-rT})
        if call_book and put_book and call_book["BUY"] and call_book["SELL"] and put_book["BUY"] and put_book["SELL"]:
            call_bid = max(call_book["BUY"].keys())
            call_ask = min(call_book["SELL"].keys())
            put_bid = max(put_book["BUY"].keys())
            put_ask = min(put_book["SELL"].keys())

            call_mid = (call_bid + call_ask) / 2.0
            put_mid = (put_bid + put_ask) / 2.0

            pv_strike = self.strike_price * math.exp(-self.risk_free_rate * self.time_to_expiry)
            theoretical_diff = underlying_mid - pv_strike
            actual_diff = call_mid - put_mid
            diff_error = actual_diff - theoretical_diff

            call_spread = call_ask - call_bid
            put_spread = put_ask - put_bid
            threshold = call_spread + put_spread

            # If call overpriced: sell call, buy put, buy underlying
            if diff_error > threshold and abs(self.positions[call_name]) < self.position_limit:
                size = 1
                orders.append(Order(call_name, call_bid, -size))
                self.positions[call_name] -= size
                orders.append(Order(put_name, put_ask, size))
                self.positions[put_name] += size
                orders.append(Order(underlying, underlying_ask, size))
                self.positions[underlying] += size

            # If put overpriced: buy call, sell put, sell underlying
            elif diff_error < -threshold and abs(self.positions[put_name]) < self.position_limit:
                size = 1
                orders.append(Order(call_name, call_ask, size))
                self.positions[call_name] += size
                orders.append(Order(put_name, put_bid, -size))
                self.positions[put_name] -= size
                orders.append(Order(underlying, underlying_bid, -size))
                self.positions[underlying] -= size

        # Strategy 2: Pricing via Black-Scholes
        if call_book and call_book["BUY"] and call_book["SELL"]:
            call_bid = max(call_book["BUY"].keys())
            call_ask = min(call_book["SELL"].keys())
            fair_call = self._black_scholes_call(underlying_mid, self.strike_price,
                                                 self.time_to_expiry, self.risk_free_rate, realized_vol)
            call_spread = call_ask - call_bid
            # Buy call if underpriced
            if call_ask < fair_call - call_spread:
                if abs(self.positions[call_name]) < self.position_limit:
                    orders.append(Order(call_name, call_ask, 1))
                    self.positions[call_name] += 1
            # Sell call if overpriced
            if call_bid > fair_call + call_spread:
                if abs(self.positions[call_name]) < self.position_limit:
                    orders.append(Order(call_name, call_bid, -1))
                    self.positions[call_name] -= 1

        if put_book and put_book["BUY"] and put_book["SELL"]:
            put_bid = max(put_book["BUY"].keys())
            put_ask = min(put_book["SELL"].keys())
            fair_put = self._black_scholes_put(underlying_mid, self.strike_price,
                                               self.time_to_expiry, self.risk_free_rate, realized_vol)
            put_spread = put_ask - put_bid
            if put_ask < fair_put - put_spread:
                if abs(self.positions[put_name]) < self.position_limit:
                    orders.append(Order(put_name, put_ask, 1))
                    self.positions[put_name] += 1
            if put_bid > fair_put + put_spread:
                if abs(self.positions[put_name]) < self.position_limit:
                    orders.append(Order(put_name, put_bid, -1))
                    self.positions[put_name] -= 1

        # Strategy 3: Straddle (volatility arbitrage)
        if call_book and put_book and call_book["BUY"] and call_book["SELL"] and put_book["BUY"] and put_book["SELL"]:
            call_bid = max(call_book["BUY"].keys())
            call_ask = min(call_book["SELL"].keys())
            put_bid = max(put_book["BUY"].keys())
            put_ask = min(put_book["SELL"].keys())
            call_mid = (call_bid + call_ask) / 2.0

            implied_vol = self._implied_volatility(call_mid, underlying_mid,
                                                   self.strike_price, self.time_to_expiry, self.risk_free_rate)
            vol_diff = implied_vol - realized_vol
            vol_threshold = 0.05

            # If implied volatility lower, options cheap => buy straddle
            if vol_diff < -vol_threshold:
                if abs(self.positions[call_name]) < self.position_limit and abs(self.positions[put_name]) < self.position_limit:
                    orders.append(Order(call_name, call_ask, 1))
                    self.positions[call_name] += 1
                    orders.append(Order(put_name, put_ask, 1))
                    self.positions[put_name] += 1

            # If implied vol higher, options expensive => sell straddle
            elif vol_diff > vol_threshold:
                if abs(self.positions[call_name]) < self.position_limit and abs(self.positions[put_name]) < self.position_limit:
                    orders.append(Order(call_name, call_bid, -1))
                    self.positions[call_name] -= 1
                    orders.append(Order(put_name, put_bid, -1))
                    self.positions[put_name] -= 1

        return orders

    def _black_scholes_call(self, S, K, T, r, sigma):
        if T <= 0 or sigma <= 0:
            return max(S - K, 0.0)
        d1 = (math.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * math.sqrt(T))
        d2 = d1 - sigma * math.sqrt(T)
        N = lambda x: 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))
        return S * N(d1) - K * math.exp(-r * T) * N(d2)

    def _black_scholes_put(self, S, K, T, r, sigma):
        call_price = self._black_scholes_call(S, K, T, r, sigma)
        return call_price - S + K * math.exp(-r * T)

    def _implied_volatility(self, market_price, S, K, T, r):
        sigma = 0.2
        for _ in range(20):
            price = self._black_scholes_call(S, K, T, r, sigma)
            d1 = (math.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * math.sqrt(T))
            vega = S * math.sqrt(T) * (1.0 / math.sqrt(2*math.pi)) * math.exp(-0.5 * d1**2)
            if vega <= 0:
                break
            diff = price - market_price
            if abs(diff) < 1e-3:
                break
            sigma -= diff / vega
            sigma = max(1e-4, min(sigma, 5.0))
        return sigma
